<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C·ªù L·∫≠t Online - Enhanced Multiplayer Othello</title>
    <style>
        :root {
            /* Default Theme */
            --bg-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --bg-secondary: rgba(255, 255, 255, 0.1);
            --text-primary: white;
            --text-secondary: rgba(255, 255, 255, 0.9);
            --accent-color: #FFD700;
            --success-color: #00ff88;
            --error-color: #ff6b6b;
            --board-bg: #2d3748;
            --cell-bg: #4a5568;
            --cell-hover: #718096;
        }

        /* Dark Theme */
        [data-theme="dark"] {
            --bg-primary: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            --bg-secondary: rgba(0, 0, 0, 0.3);
            --text-primary: #ecf0f1;
            --text-secondary: #bdc3c7;
            --accent-color: #e74c3c;
            --success-color: #27ae60;
            --error-color: #e74c3c;
            --board-bg: #1a1a1a;
            --cell-bg: #2c2c2c;
            --cell-hover: #3c3c3c;
        }

        /* Neon Theme */
        [data-theme="neon"] {
            --bg-primary: linear-gradient(135deg, #0f0f0f 0%, #1a1a2e 100%);
            --bg-secondary: rgba(16, 213, 194, 0.1);
            --text-primary: #00ff88;
            --text-secondary: #10d5c2;
            --accent-color: #ff0080;
            --success-color: #00ff88;
            --error-color: #ff0040;
            --board-bg: #000;
            --cell-bg: #1a1a2e;
            --cell-hover: #16213e;
        }

        /* Nature Theme */
        [data-theme="nature"] {
            --bg-primary: linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%);
            --bg-secondary: rgba(255, 255, 255, 0.2);
            --text-primary: #2d5016;
            --text-secondary: #3e6b1f;
            --accent-color: #ff6b35;
            --success-color: #4caf50;
            --error-color: #f44336;
            --board-bg: #6b5b54;
            --cell-bg: #8b7355;
            --cell-hover: #a0845c;
        }

        /* Ocean Theme */
        [data-theme="ocean"] {
            --bg-primary: linear-gradient(135deg, #667db6 0%, #0082c8 100%);
            --bg-secondary: rgba(255, 255, 255, 0.15);
            --text-primary: white;
            --text-secondary: #e1f5fe;
            --accent-color: #ffd54f;
            --success-color: #26c6da;
            --error-color: #ef5350;
            --board-bg: #1565c0;
            --cell-bg: #1976d2;
            --cell-hover: #1e88e5;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .title {
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 10px;
            background: linear-gradient(45deg, var(--accent-color), var(--success-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            color: var(--text-secondary);
        }

        /* Menu screens */
        .screen {
            display: none;
            width: 100%;
            max-width: 500px;
            text-align: center;
        }

        .screen.active {
            display: block;
        }

        .menu-card {
            background: var(--bg-secondary);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin: 20px 0;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .input-group {
            margin: 20px 0;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: var(--text-primary);
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 5px;
            min-width: 150px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
        }

        .btn-info {
            background: linear-gradient(45deg, #feca57, #ff9ff3);
            color: white;
        }

        .btn-ai {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 0.9rem;
            min-width: 100px;
        }

        /* Room info */
        .room-info {
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid var(--success-color);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
        }

        .room-id {
            font-size: 2rem;
            font-weight: bold;
            color: var(--success-color);
            margin-bottom: 10px;
        }

        .share-link {
            font-size: 0.9rem;
            word-break: break-all;
            background: var(--bg-secondary);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
        }

        /* Game interface */
        .game-container {
            display: flex;
            flex-direction: column; /* Changed to column for overall layout */
            align-items: center;
            gap: 20px;
            max-width: 100%;
        }

        .top-section {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            max-width: 1200px;
        }
        /* New rule for AI/Local layout */
        .game-container.local-ai-layout .top-section {
            flex-direction: column; /* Stack player cards and chat vertically */
            align-items: center;
        }


        .players-section {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .player-card {
            background: var(--bg-secondary);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            min-width: 200px;
            border: 3px solid transparent;
            transition: all 0.3s ease;
        }

        .player-card.active {
            border-color: var(--success-color);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
            transform: scale(1.05);
        }

        .player-card.offline {
            opacity: 0.6;
            border-color: var(--error-color);
        }

        .player-card.ai {
            border-color: #667eea;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.2));
        }

        .player-name {
            font-size: 1.2rem;
            margin-bottom: 10px;
            font-weight: bold;
            color: var(--text-primary);
        }

        .emoji-selector {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin-bottom: 10px;
        }

        .emoji-option {
            font-size: 1.5rem;
            padding: 5px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
            background: rgba(255, 255, 255, 0.1); /* Added for better visibility */
        }

        .emoji-option:hover {
            transform: scale(1.2);
            background: var(--bg-secondary);
        }

        .emoji-option.selected {
            border-color: var(--accent-color);
            background: rgba(255, 215, 0, 0.3);
        }

        .score {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent-color);
        }

        /* Chat section */
        .chat-section {
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 15px;
            width: 300px;
            height: 400px;
            display: flex;
            flex-direction: column;
        }

        .chat-header {
            font-weight: bold;
            margin-bottom: 10px;
            color: var(--text-primary);
            text-align: center;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 5px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            background: rgba(0,0,0,0.1);
        }

        .chat-message {
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 8px;
            background: var(--bg-secondary);
            font-size: 0.9rem;
        }

        .chat-sender {
            font-weight: bold;
            color: var(--accent-color);
        }

        .chat-input-container {
            display: flex;
            gap: 5px;
        }

        .chat-input {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 15px;
            background: rgba(255,255,255,0.9);
            color: #333;
        }

        .chat-send {
            padding: 8px 12px;
            border: none;
            border-radius: 50%;
            background: var(--success-color);
            color: white;
            cursor: pointer;
        }

        /* Stats and leaderboard */
        .stats-section {
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 15px;
            width: 300px;
            height: 400px;
            overflow-y: auto;
        }

        .stats-header {
            font-weight: bold;
            margin-bottom: 15px;
            color: var(--text-primary);
            text-align: center;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 5px;
            background: rgba(0,0,0,0.1);
            border-radius: 5px;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 8px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border-left: 4px solid var(--accent-color);
        }

        .leaderboard-rank {
            font-weight: bold;
            color: var(--accent-color);
        }

        .leaderboard-name {
            flex: 1;
            margin: 0 10px;
        }

        .leaderboard-rating {
            font-weight: bold;
            color: var(--success-color);
        }

        /* Theme selector */
        .theme-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .theme-option {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s ease;
        }

        .theme-option:hover {
            transform: scale(1.1);
        }

        .theme-option.selected {
            border-color: var(--accent-color);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .theme-default { background: linear-gradient(135deg, #667eea, #764ba2); }
        .theme-dark { background: linear-gradient(135deg, #2c3e50, #34495e); }
        .theme-neon { background: linear-gradient(135deg, #0f0f0f, #1a1a2e); }
        .theme-nature { background: linear-gradient(135deg, #56ab2f, #a8e6cf); }
        .theme-ocean { background: linear-gradient(135deg, #667db6, #0082c8); }

        .board-container {
            position: relative;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            background: var(--board-bg);
            padding: 10px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .cell {
            width: 40px;
            height: 40px;
            background: var(--cell-bg);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .cell:hover {
            background: var(--cell-hover);
            transform: scale(1.05);
        }

        .cell.valid-move {
            border: 2px solid var(--success-color);
            animation: sparkle 1s infinite;
            background: rgba(0, 255, 136, 0.2);
        }

        .cell.valid-move:hover {
            background: rgba(0, 255, 136, 0.4);
        }

        @keyframes sparkle {
            0%, 100% { box-shadow: 0 0 5px rgba(0, 255, 136, 0.5); }
            50% { box-shadow: 0 0 15px rgba(0, 255, 136, 0.8); }
        }

        .piece {
            font-size: 1.8rem;
            animation: placepiece 0.3s ease-out;
            transition: transform 0.3s ease;
        }

        .piece.flipping {
            animation: flip 0.6s ease-in-out;
        }

        @keyframes placepiece {
            0% { transform: scale(0) rotate(180deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        @keyframes flip {
            0% { transform: rotateY(0deg); }
            50% { transform: rotateY(90deg); }
            100% { transform: rotateY(0deg); }
        }

        .turn-indicator {
            text-align: center;
            font-size: 1.3rem;
            margin-bottom: 20px;
            padding: 10px;
            background: var(--bg-secondary);
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .connection-status.connected {
            background: var(--success-color);
            color: white;
        }

        .connection-status.disconnected {
            background: var(--error-color);
            color: white;
        }

        .connection-status.connecting {
            background: var(--accent-color);
            color: white;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        /* Toast Notifications */
        #toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
        }

        .toast {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            min-width: 200px;
            max-width: 300px;
            text-align: center;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }

        .toast.success { background: #4CAF50; }
        .toast.error { background: #F44336; }
        .toast.info { background: #2196F3; }


        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: var(--bg-primary);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            max-width: 500px;
            margin: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            color: var(--text-primary);
        }

        .modal h2 {
            color: var(--accent-color);
            margin-bottom: 20px;
            font-size: 2rem;
        }

        .modal p {
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .game-over {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .game-over-content {
            text-align: center;
            color: white;
            animation: bounceIn 0.8s ease-out;
        }

        .winner-announcement {
            font-size: 3rem;
            margin-bottom: 20px;
            background: linear-gradient(45deg, var(--accent-color), var(--success-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .final-score {
            font-size: 1.5rem;
            margin-bottom: 30px;
        }

        @keyframes bounceIn {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.05); }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); opacity: 1; }
        }

        /* AI thinking indicator */
        .ai-thinking {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-weight: bold;
            animation: pulse 1s infinite;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            justify-content: center;
        }

        .tab {
            padding: 8px 16px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            background: rgba(255,255,255,0.2);
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        .tab.active {
            background: var(--accent-color);
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .title {
                font-size: 2rem;
            }
            /* Adjusted for AI/Local layout on small screens */
            .top-section, .game-container.local-ai-layout .top-section {
                flex-direction: column;
            }
            .players-section {
                flex-direction: column;
                align-items: center;
            }
            .player-card, .chat-section, .stats-section {
                min-width: 280px;
                width: 100%;
                max-width: 350px;
            }
            .cell {
                width: 35px;
                height: 35px;
            }
            .piece {
                font-size: 1.5rem;
            }
            .btn {
                width: 200px;
                margin: 5px 0;
            }
        }

        @media (max-width: 480px) {
            .cell {
                width: 30px;
                height: 30px;
            }
            .piece {
                font-size: 1.2rem;
            }
            .board {
                padding: 5px;
            }
        }
    </style>
</head>
<body data-theme="default">
    <div id="toast-container"></div> <div class="header">
        <h1 class="title">üåê C·ªù L·∫≠t Online Enhanced</h1>
        <p class="subtitle">AI ‚Ä¢ Chat ‚Ä¢ Leaderboard ‚Ä¢ Stats ‚Ä¢ Themes</p>
    </div>

    <div class="connection-status" id="connection-status">
        üîÑ ƒêang k·∫øt n·ªëi...
    </div>

    <div class="screen active" id="main-menu">
        <div class="menu-card">
            <h2>üì± Ch√†o m·ª´ng ƒë·∫øn v·ªõi C·ªù L·∫≠t Online Enhanced!</h2>
            <p>Ch∆°i c·ªù l·∫≠t v·ªõi b·∫°n b√®, AI, v√† nhi·ªÅu t√≠nh nƒÉng m·ªõi</p>
            <div class="input-group">
                <label for="player-name">üë§ T√™n c·ªßa b·∫°n:</label>
                <input type="text" id="player-name" placeholder="Nh·∫≠p t√™n c·ªßa b·∫°n..." maxlength="20">
            </div>
            <div class="theme-selector">
                <div class="theme-option theme-default selected" data-theme="default" title="Default"></div>
                <div class="theme-option theme-dark" data-theme="dark" title="Dark"></div>
                <div class="theme-option theme-neon" data-theme="neon" title="Neon"></div>
                <div class="theme-option theme-nature" data-theme="nature" title="Nature"></div>
                <div class="theme-option theme-ocean" data-theme="ocean" title="Ocean"></div>
            </div>
            <div style="margin: 30px 0;">
                <button class="btn btn-primary" onclick="createRoom('online')">
                    üè† T·∫°o Ph√≤ng Online
                </button>
                <button class="btn btn-secondary" onclick="showJoinRoom()">
                    üö™ V√†o Ph√≤ng
                </button>
            </div>
            <div style="margin: 20px 0;">
                <button class="btn btn-ai" onclick="showAIMenu()">
                    ü§ñ Ch∆°i v·ªõi AI
                </button>
                <button class="btn btn-info" onclick="playOffline()">
                    üéÆ Ch∆°i Local
                </button>
            </div>
            <div style="margin: 20px 0;">
                <button class="btn btn-secondary btn-small" onclick="showLeaderboard()">
                    üèÜ B·∫£ng X·∫øp H·∫°ng
                </button>
                <button class="btn btn-info btn-small" onclick="showStats()">
                    üìä Th·ªëng K√™
                </button>
            </div>
        </div>
    </div>

    <div class="screen" id="ai-menu-screen">
        <div class="menu-card">
            <h2>ü§ñ Ch·ªçn ƒê·ªô Kh√≥ AI</h2>
            <div class="input-group">
                <label for="ai-difficulty">üéØ ƒê·ªô kh√≥:</label>
                <select id="ai-difficulty">
                    <option value="easy">üòä D·ªÖ - AI M√®o</option>
                    <option value="medium" selected>ü§î Trung B√¨nh - AI Th√¥ng Minh</option>
                    <option value="hard">üòà Kh√≥ - AI Si√™u C·∫•p</option>
                </select>
            </div>
            <div style="margin: 20px 0;">
                <button class="btn btn-ai" onclick="createAIRoom()">
                    üöÄ B·∫Øt ƒê·∫ßu v·ªõi AI
                </button>
                <button class="btn btn-secondary" onclick="backToMenu()">
                    ‚¨ÖÔ∏è Quay L·∫°i
                </button>
            </div>
        </div>
    </div>

    <div class="screen" id="join-room-screen">
        <div class="menu-card">
            <h2>üö™ Tham Gia Ph√≤ng</h2>
            <div class="input-group">
                <label for="room-id-input">üÜî ID Ph√≤ng:</label>
                <input type="text" id="room-id-input" placeholder="Nh·∫≠p ID ph√≤ng...">
            </div>
            <button class="btn btn-primary" onclick="joinRoom()">
                üöÄ Tham Gia
            </button>
            <button class="btn btn-secondary" onclick="backToMenu()">
                ‚¨ÖÔ∏è Quay L·∫°i
            </button>
        </div>
    </div>

    <div class="screen" id="room-lobby-screen">
        <div class="menu-card">
            <h2>üè† Ph√≤ng Game <span id="lobby-room-id"></span></h2>
            <div class="room-info">
                <p>ID Ph√≤ng: <span class="room-id" id="display-room-id"></span></p>
                <p>Link Chia S·∫ª: <span class="share-link" id="share-link"></span></p>
                <button class="btn btn-info btn-small" onclick="copyShareLink()">Sao ch√©p Link</button>
                <p style="margin-top: 15px;">Ng∆∞·ªùi ch∆°i hi·ªán t·∫°i: <span id="players-in-lobby">0/2</span></p>
                <div id="lobby-player-names" style="margin-top: 10px; font-weight: bold;"></div>
            </div>
            <button class="btn btn-primary" id="start-game-button" onclick="startGame()" disabled>
                ‚ñ∂Ô∏è B·∫Øt ƒê·∫ßu Game
            </button>
            <button class="btn btn-secondary" onclick="leaveRoom()">
                ‚Ü©Ô∏è R·ªùi Ph√≤ng
            </button>
        </div>
    </div>

    <div class="screen" id="game-screen">
        <div class="game-container">
            <div class="top-section">
                <div class="players-section">
                    <div class="player-card" id="player-black-card">
                        <span class="player-name" id="player-black-name"></span>
                        <div class="emoji-selector" id="emoji-selector-black">
                            </div>
                        <span class="score" id="score-black">2</span>
                    </div>
                    <div class="player-card" id="player-white-card">
                        <span class="player-name" id="player-white-name"></span>
                        <div class="emoji-selector" id="emoji-selector-white">
                            </div>
                        <span class="score" id="score-white">2</span>
                    </div>
                </div>
            </div> <div class="turn-indicator" id="turn-indicator">ƒêang ch·ªù ng∆∞·ªùi ch∆°i...</div>
            <div class="board-container">
                <div class="board" id="game-board"></div>
                <div class="ai-thinking" id="ai-thinking-indicator" style="display: none;">
                    AI ƒëang suy nghƒ©...
                </div>
            </div>

            <div class="chat-section">
                <div class="tabs">
                    <button class="tab active" data-tab="chat-tab">üí¨ Chat</button>
                    <button class="tab" data-tab="leaderboard-tab" onclick="game.loadLeaderboardData()">üèÜ BXH</button>
                    <button class="tab" data-tab="stats-tab" onclick="game.loadStatsData(game.playerName)">üìä Stats</button>
                </div>
                <div class="tab-content active" id="chat-tab-content">
                    <div class="chat-messages" id="chat-messages"></div>
                    <div class="chat-input-container">
                        <input type="text" id="chat-input" class="chat-input" placeholder="Nh·∫Øn tin...">
                        <button class="chat-send" onclick="sendChatMessage()">‚ñ∂Ô∏è</button>
                    </div>
                </div>
                <div class="tab-content" id="leaderboard-tab-content">
                    <h3 class="stats-header">üèÜ B·∫£ng X·∫øp H·∫°ng</h3>
                    <ul id="leaderboard-list" style="list-style: none; padding: 0;">
                        <p>ƒêang t·∫£i b·∫£ng x·∫øp h·∫°ng...</p>
                    </ul>
                </div>
                <div class="tab-content" id="stats-tab-content">
                    <h3 class="stats-header">üìä Th·ªëng K√™ Ng∆∞·ªùi Ch∆°i: <span id="stats-player-name"></span></h3>
                    <div id="stats-list">
                        <p>Ch·ªçn t√™n ng∆∞·ªùi ch∆°i ƒë·ªÉ xem th·ªëng k√™.</p>
                    </div>
                </div>
            </div>

            <div style="margin-top: 20px;">
                <button class="btn btn-secondary btn-small" onclick="resetGame()">üîÑ Ch∆°i L·∫°i</button>
                <button class="btn btn-info btn-small" onclick="showRules()">‚ùì Lu·∫≠t Ch∆°i</button>
                <button class="btn btn-primary btn-small" onclick="leaveGame()">‚Ü©Ô∏è Tho√°t Game</button>
            </div>
        </div>
    </div>

    <div class="modal" id="rules-modal">
        <div class="modal-content">
            <h2>‚ùì Lu·∫≠t Ch∆°i C·ªù L·∫≠t (Othello/Reversi)</h2>
            <p>
                M·ª•c ti√™u c·ªßa tr√≤ ch∆°i l√† c√≥ nhi·ªÅu qu√¢n c·ªù c·ªßa b·∫°n h∆°n ƒë·ªëi th·ªß khi b√†n c·ªù ƒë·∫ßy ho·∫∑c kh√¥ng c√≤n n∆∞·ªõc ƒëi h·ª£p l·ªá.
            </p>
            <p>
                B·∫°n v√† ƒë·ªëi th·ªß s·∫Ω thay phi√™n ƒë·∫∑t qu√¢n c·ªù c·ªßa m√¨nh (ƒëen ho·∫∑c tr·∫Øng) l√™n m·ªôt √¥ tr·ªëng tr√™n b√†n c·ªù.
                N∆∞·ªõc ƒëi h·ª£p l·ªá ph·∫£i "k·∫πp" m·ªôt ho·∫∑c nhi·ªÅu qu√¢n c·ªù c·ªßa ƒë·ªëi th·ªß gi·ªØa qu√¢n c·ªù b·∫°n v·ª´a ƒë·∫∑t v√† m·ªôt qu√¢n c·ªù kh√°c c·ªßa b·∫°n ƒë√£ c√≥ s·∫µn tr√™n b√†n.
            </p>
            <p>
                Sau khi ƒë·∫∑t qu√¢n c·ªù, t·∫•t c·∫£ c√°c qu√¢n c·ªù c·ªßa ƒë·ªëi th·ªß b·ªã k·∫πp gi·ªØa hai qu√¢n c·ªù c·ªßa b·∫°n s·∫Ω b·ªã l·∫≠t l·∫°i th√†nh m√†u c·ªßa b·∫°n.
            </p>
            <p>
                N·∫øu m·ªôt ng∆∞·ªùi ch∆°i kh√¥ng c√≥ n∆∞·ªõc ƒëi h·ª£p l·ªá, l∆∞·ª£t ch∆°i s·∫Ω t·ª± ƒë·ªông chuy·ªÉn sang ƒë·ªëi th·ªß.
                N·∫øu c·∫£ hai ng∆∞·ªùi ch∆°i ƒë·ªÅu kh√¥ng c√≥ n∆∞·ªõc ƒëi h·ª£p l·ªá, tr√≤ ch∆°i k·∫øt th√∫c.
            </p>
            <p>
                Ng∆∞·ªùi ch∆°i c√≥ s·ªë l∆∞·ª£ng qu√¢n c·ªù nhi·ªÅu h∆°n tr√™n b√†n khi tr√≤ ch∆°i k·∫øt th√∫c s·∫Ω th·∫Øng.
            </p>
            <button class="btn btn-primary" onclick="closeModal()">ƒê√£ Hi·ªÉu</button>
        </div>
    </div>

    <div class="game-over" id="game-over-screen">
        <div class="game-over-content">
            <div class="winner-announcement" id="winner-announcement"></div>
            <div class="final-score" id="final-score"></div>
            <button class="btn btn-primary" onclick="game.resetGame()">Ch∆°i L·∫°i</button>
            <button class="btn btn-secondary" onclick="game.leaveGame()">V·ªÅ Menu Ch√≠nh</button>
        </div>
    </div>


    <script src="/socket.io/socket.io.js"></script>
    <script>
        let game; // Global game instance

        // Helper for showing toast notifications
        function showToast(message, type = 'info', duration = 3000) {
            const toastContainer = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.classList.add('toast', type);
            toast.textContent = message;
            toastContainer.appendChild(toast);

            // Trigger reflow to apply initial opacity/transform
            void toast.offsetWidth; 
            toast.classList.add('show');

            setTimeout(() => {
                toast.classList.remove('show');
                toast.addEventListener('transitionend', () => toast.remove());
            }, duration);
        }

        class EnhancedOthelloGame {
            constructor() {
                this.socket = null;
                this.playerName = '';
                this.roomId = null;
                this.gameMode = 'offline'; // 'offline', 'ai', 'online'
                this.isOnlineMode = false;
                this.isHost = false;
                this.board = Array(8).fill(0).map(() => Array(8).fill(0));
                this.currentPlayer = 1; // 1 for Black, 2 for White
                this.scores = { 1: 2, 2: 2 }; // Initial pieces
                this.validMoves = [];
                this.gameStarted = false;
                this.gameOver = false;
                this.aiDifficulty = 'medium'; // Default AI difficulty
                this.playerEmojis = {
                    1: '‚ö´', // Default Black piece
                    2: '‚ö™'  // Default White piece
                };
                this.selectedPlayerEmoji = {
                    1: '‚ö´',
                    2: '‚ö™'
                }; // To store player's chosen emoji for their color

                this.initUI();
                this.setupEventListeners();
                this.loadPlayerName();
                this.loadTheme();
                this.loadSelectedEmojis(); // Load previously selected emojis
            }

            loadSelectedEmojis() {
                const storedBlackEmoji = localStorage.getItem('playerBlackEmoji');
                const storedWhiteEmoji = localStorage.getItem('playerWhiteEmoji');
                if (storedBlackEmoji) {
                    this.selectedPlayerEmoji[1] = storedBlackEmoji;
                }
                if (storedWhiteEmoji) {
                    this.selectedPlayerEmoji[2] = storedWhiteEmoji;
                }
                this.updateEmojiSelectors(); // Update UI to reflect loaded emojis
            }

            saveSelectedEmojis() {
                localStorage.setItem('playerBlackEmoji', this.selectedPlayerEmoji[1]);
                localStorage.setItem('playerWhiteEmoji', this.selectedPlayerEmoji[2]);
            }

            initUI() {
                this.elements = {
                    playerNameInput: document.getElementById('player-name'),
                    mainMenuScreen: document.getElementById('main-menu'),
                    aiMenuScreen: document.getElementById('ai-menu-screen'),
                    joinRoomScreen: document.getElementById('join-room-screen'),
                    roomLobbyScreen: document.getElementById('room-lobby-screen'),
                    gameScreen: document.getElementById('game-screen'),
                    connectionStatus: document.getElementById('connection-status'),
                    displayRoomId: document.getElementById('display-room-id'),
                    lobbyRoomId: document.getElementById('lobby-room-id'),
                    shareLink: document.getElementById('share-link'),
                    playersInLobby: document.getElementById('players-in-lobby'),
                    lobbyPlayerNames: document.getElementById('lobby-player-names'),
                    startGameButton: document.getElementById('start-game-button'),
                    playerBlackName: document.getElementById('player-black-name'),
                    playerWhiteName: document.getElementById('player-white-name'),
                    scoreBlack: document.getElementById('score-black'),
                    scoreWhite: document.getElementById('score-white'),
                    turnIndicator: document.getElementById('turn-indicator'),
                    gameBoard: document.getElementById('game-board'),
                    chatMessages: document.getElementById('chat-messages'),
                    chatInput: document.getElementById('chat-input'),
                    leaderboardList: document.getElementById('leaderboard-list'),
                    statsPlayerName: document.getElementById('stats-player-name'),
                    statsList: document.getElementById('stats-list'),
                    rulesModal: document.getElementById('rules-modal'),
                    gameOverScreen: document.getElementById('game-over-screen'),
                    winnerAnnouncement: document.getElementById('winner-announcement'),
                    finalScore: document.getElementById('final-score'),
                    aiThinkingIndicator: document.getElementById('ai-thinking-indicator'),
                    roomIdInput: document.getElementById('room-id-input'),
                    gameContainer: document.querySelector('.game-container') // Reference to game container for layout changes
                };

                this.playerEmojis[1] = this.selectedPlayerEmoji[1];
                this.playerEmojis[2] = this.selectedPlayerEmoji[2];

                // Populate emoji selectors
                this.populateEmojiSelector('emoji-selector-black', 1);
                this.populateEmojiSelector('emoji-selector-white', 2);
            }

            populateEmojiSelector(elementId, playerColor) {
                const selector = document.getElementById(elementId);
                selector.innerHTML = '';
                const emojis = ['‚ö´', '‚ö™', 'üî¥', 'üîµ', 'üü¢', 'üü°', 'üü£', 'üü§', 'üü†', '‚ú®', '‚≠ê', 'üçÄ', 'üçé', 'üíé']; // Example emojis

                emojis.forEach(emoji => {
                    const option = document.createElement('span');
                    option.classList.add('emoji-option');
                    option.textContent = emoji;
                    option.dataset.emoji = emoji;
                    if (this.selectedPlayerEmoji[playerColor] === emoji) {
                        option.classList.add('selected');
                    }
                    option.addEventListener('click', () => {
                        this.selectedPlayerEmoji[playerColor] = emoji;
                        this.playerEmojis[playerColor] = emoji; // Update the actual game piece emoji
                        this.saveSelectedEmojis();
                        this.updateEmojiSelectors(); // Update UI to reflect selection
                        this.renderBoard(); // Re-render board with new piece
                    });
                    selector.appendChild(option);
                });
            }

            updateEmojiSelectors() {
                const selectors = document.querySelectorAll('.emoji-selector');
                selectors.forEach(selector => {
                    const playerColor = selector.id.includes('black') ? 1 : 2;
                    Array.from(selector.children).forEach(option => {
                        if (option.dataset.emoji === this.selectedPlayerEmoji[playerColor]) {
                            option.classList.add('selected');
                        } else {
                            option.classList.remove('selected');
                        }
                    });
                });
            }


            setupEventListeners() {
                // Theme selection
                document.querySelectorAll('.theme-option').forEach(option => {
                    option.addEventListener('click', (e) => {
                        const theme = e.target.dataset.theme;
                        document.body.dataset.theme = theme;
                        localStorage.setItem('selectedTheme', theme);
                        document.querySelectorAll('.theme-option').forEach(opt => opt.classList.remove('selected'));
                        e.target.classList.add('selected');
                    });
                });

                // Chat input enter key
                this.elements.chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.sendChatMessage();
                    }
                });

                // Tab switching
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        this.switchTab(tab.dataset.tab);
                    });
                });
            }

            loadTheme() {
                const savedTheme = localStorage.getItem('selectedTheme') || 'default';
                document.body.dataset.theme = savedTheme;
                document.querySelectorAll('.theme-option').forEach(option => {
                    if (option.dataset.theme === savedTheme) {
                        option.classList.add('selected');
                    } else {
                        option.classList.remove('selected');
                    }
                });
            }

            loadPlayerName() {
                const savedName = localStorage.getItem('playerName');
                if (savedName) {
                    this.elements.playerNameInput.value = savedName;
                    this.playerName = savedName;
                }
            }

            savePlayerName() {
                this.playerName = this.elements.playerNameInput.value.trim();
                if (this.playerName) {
                    localStorage.setItem('playerName', this.playerName);
                } else {
                    localStorage.removeItem('playerName');
                }
            }

            showScreen(screenId) {
                document.querySelectorAll('.screen').forEach(screen => {
                    screen.classList.remove('active');
                });
                document.getElementById(screenId).classList.add('active');
            }

            showToast(message, type = 'info', duration = 3000) {
                showToast(message, type, duration);
            }

            // Game Logic (Client-side simulation for offline/AI, and online display)
            initializeBoard() {
                this.board = Array(8).fill(0).map(() => Array(8).fill(0));
                this.board[3][3] = 2; // White
                this.board[3][4] = 1; // Black
                this.board[4][3] = 1; // Black
                this.board[4][4] = 2; // White
                this.currentPlayer = 1; // Black starts
                this.scores = { 1: 2, 2: 2 };
                this.gameStarted = false;
                this.gameOver = false;
                this.winner = null;
            }

            updateScores() {
                let blackCount = 0;
                let whiteCount = 0;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (this.board[r][c] === 1) blackCount++;
                        else if (this.board[r][c] === 2) whiteCount++;
                    }
                }
                this.scores[1] = blackCount;
                this.scores[2] = whiteCount;

                this.elements.scoreBlack.textContent = blackCount;
                this.elements.scoreWhite.textContent = whiteCount;
            }

            renderBoard() {
                this.elements.gameBoard.innerHTML = '';
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.row = r;
                        cell.dataset.col = c;

                        if (this.board[r][c] === 1) {
                            cell.innerHTML = `<span class="piece">${this.playerEmojis[1]}</span>`;
                        } else if (this.board[r][c] === 2) {
                            cell.innerHTML = `<span class="piece">${this.playerEmojis[2]}</span>`;
                        }

                        if (!this.gameOver && this.gameStarted && this.isValidClientMove(r, c, this.currentPlayer)) {
                            cell.classList.add('valid-move');
                            cell.addEventListener('click', () => this.handleCellClick(r, c));
                        }
                        this.elements.gameBoard.appendChild(cell);
                    }
                }
            }

            isValidClientMove(r, c, playerColor) {
                // This is a simplified check for client-side display of valid moves
                // The actual move validation happens on the server (for online) or in the AI/offline logic
                // It just checks if placing a piece at (r,c) would flip at least one opponent piece.
                if (this.board[r][c] !== 0) return false;

                const opponentColor = playerColor === 1 ? 2 : 1;
                const directions = [
                    [-1, 0], [1, 0], [0, -1], [0, 1],
                    [-1, -1], [-1, 1], [1, -1], [1, 1]
                ];

                for (const [dr, dc] of directions) {
                    let foundOpponent = false;
                    let currentR = r + dr;
                    let currentC = c + dc;

                    while (currentR >= 0 && currentR < 8 && currentC >= 0 && currentC < 8) {
                        if (this.board[currentR][currentC] === opponentColor) {
                            foundOpponent = true;
                        } else if (this.board[currentR][currentC] === playerColor && foundOpponent) {
                            return true;
                        } else {
                            break;
                        }
                        currentR += dr;
                        currentC += dc;
                    }
                }
                return false;
            }

            applyMove(r, c, playerColor, flippedPieces) {
                // Animate piece placement
                const cell = this.elements.gameBoard.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                if (cell) {
                    cell.innerHTML = `<span class="piece" style="font-size: 0; transform: scale(0);">${this.playerEmojis[playerColor]}</span>`;
                    setTimeout(() => {
                        const pieceElement = cell.querySelector('.piece');
                        if (pieceElement) {
                            pieceElement.style.fontSize = '1.8rem';
                            pieceElement.style.transform = 'scale(1)';
                        }
                    }, 50); // Small delay to ensure render before animation
                }

                // Apply flips
                flippedPieces.forEach(({ r: flipR, c: flipC }) => {
                    const flippedCell = this.elements.gameBoard.querySelector(`[data-row="${flipR}"][data-col="${flipC}"]`);
                    if (flippedCell) {
                        const pieceElement = flippedCell.querySelector('.piece');
                        if (pieceElement) {
                            pieceElement.classList.add('flipping');
                            pieceElement.addEventListener('animationend', () => {
                                pieceElement.textContent = this.playerEmojis[playerColor];
                                pieceElement.classList.remove('flipping');
                            }, { once: true });
                        }
                    }
                });

                // Update board data
                this.board[r][c] = playerColor;
                flippedPieces.forEach(({ r: flipR, c: flipC }) => {
                    this.board[flipR][flipC] = playerColor;
                });
                this.updateScores();
            }

            handleCellClick(r, c) {
                if (!this.gameStarted || this.gameOver) return;

                if (this.gameMode === 'offline') {
                    if (this.isValidClientMove(r, c, this.currentPlayer)) {
                        const flipped = this.getPiecesToFlip(r, c, this.currentPlayer);
                        this.applyMove(r, c, this.currentPlayer, flipped);
                        this.checkGameEnd();
                        if (!this.gameOver) {
                            this.switchTurn();
                        }
                    } else {
                        this.showToast('N∆∞·ªõc ƒëi kh√¥ng h·ª£p l·ªá!', 'error');
                    }
                } else if (this.gameMode === 'ai') {
                    if (this.currentPlayer === 1 && this.isValidClientMove(r, c, this.currentPlayer)) { // Player's turn (black)
                        const flipped = this.getPiecesToFlip(r, c, this.currentPlayer);
                        this.applyMove(r, c, this.currentPlayer, flipped);
                        this.checkGameEnd();
                        if (!this.gameOver) {
                            this.switchTurn();
                            setTimeout(() => this.makeAIMove(), 1000); // AI moves after 1 second
                        }
                    } else {
                        this.showToast('ƒê√¢y kh√¥ng ph·∫£i l∆∞·ª£t c·ªßa b·∫°n ho·∫∑c n∆∞·ªõc ƒëi kh√¥ng h·ª£p l·ªá!', 'error');
                    }
                } else if (this.isOnlineMode && this.socket) {
                    // Send move to server
                    this.socket.emit('makeMove', this.roomId, r, c);
                }
            }

            getPiecesToFlip(r, c, playerColor) {
                const piecesToFlip = [];
                const opponentColor = playerColor === 1 ? 2 : 1;
                const directions = [
                    [-1, 0], [1, 0], [0, -1], [0, 1],
                    [-1, -1], [-1, 1], [1, -1], [1, 1]
                ];

                for (const [dr, dc] of directions) {
                    let line = [];
                    let currentR = r + dr;
                    let currentC = c + dc;
                    while (currentR >= 0 && currentR < 8 && currentC >= 0 && currentC < 8) {
                        if (this.board[currentR][currentC] === opponentColor) {
                            line.push({ r: currentR, c: currentC });
                        } else if (this.board[currentR][currentC] === playerColor) {
                            piecesToFlip.push(...line);
                            break;
                        } else {
                            break;
                        }
                        currentR += dr;
                        currentC += dc;
                    }
                }
                return piecesToFlip;
            }

            switchTurn() {
                this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
                const validMoves = this.getValidMoves(this.currentPlayer);
                if (validMoves.length === 0) {
                    this.showToast(`Ng∆∞·ªùi ch∆°i ${this.currentPlayer === 1 ? 'ƒêen' : 'Tr·∫Øng'} kh√¥ng c√≥ n∆∞·ªõc ƒëi. Chuy·ªÉn l∆∞·ª£t!`, 'info');
                    this.currentPlayer = this.currentPlayer === 1 ? 2 : 1; // Switch back to other player
                    const otherPlayerMoves = this.getValidMoves(this.currentPlayer);
                    if (otherPlayerMoves.length === 0) {
                        this.gameOver = true; // No moves for either player
                        this.endGame();
                        return;
                    }
                }
                this.updateTurnIndicator();
                this.renderBoard(); // Re-render to update valid moves display
            }

            updateTurnIndicator() {
                const player1Name = this.elements.playerBlackName.textContent || 'Ng∆∞·ªùi ch∆°i ƒêen';
                const player2Name = this.elements.playerWhiteName.textContent || 'Ng∆∞·ªùi ch∆°i Tr·∫Øng';

                const currentPlayerName = this.currentPlayer === 1 ? player1Name : player2Name;
                this.elements.turnIndicator.textContent = `L∆∞·ª£t c·ªßa: ${currentPlayerName} ${this.playerEmojis[this.currentPlayer]}`;

                // Update active player card
                document.getElementById('player-black-card').classList.remove('active');
                document.getElementById('player-white-card').classList.remove('active');
                if (this.currentPlayer === 1) {
                    document.getElementById('player-black-card').classList.add('active');
                } else {
                    document.getElementById('player-white-card').classList.add('active');
                }
            }

            getValidMoves(playerColor) {
                const validMoves = [];
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (this.board[r][c] === 0 && this.isValidClientMove(r, c, playerColor)) {
                            validMoves.push({ r, c });
                        }
                    }
                }
                return validMoves;
            }


            checkGameEnd() {
                const movesBlack = this.getValidMoves(1).length;
                const movesWhite = this.getValidMoves(2).length;

                if (movesBlack === 0 && movesWhite === 0 || (this.scores[1] + this.scores[2] === 64)) {
                    this.gameOver = true;
                    this.endGame();
                }
            }

            endGame() {
                this.elements.gameOverScreen.style.display = 'flex';
                let winnerText = '';
                if (this.scores[1] > this.scores[2]) {
                    winnerText = `${this.elements.playerBlackName.textContent} (${this.playerEmojis[1]}) th·∫Øng!`;
                    this.winner = this.elements.playerBlackName.textContent;
                } else if (this.scores[2] > this.scores[1]) {
                    winnerText = `${this.elements.playerWhiteName.textContent} (${this.playerEmojis[2]}) th·∫Øng!`;
                    this.winner = this.elements.playerWhiteName.textContent;
                } else {
                    winnerText = 'H√≤a!';
                    this.winner = 'H√≤a';
                }
                this.elements.winnerAnnouncement.textContent = winnerText;
                this.elements.finalScore.textContent = `T·ªâ s·ªë: ${this.scores[1]} - ${this.scores[2]}`;

                if (this.isOnlineMode && this.socket) {
                    this.socket.emit('gameOver', this.roomId, this.winner, this.scores[1], this.scores[2]);
                }
            }

            resetGame() {
                this.initializeBoard();
                this.renderBoard();
                this.updateScores();
                this.updateTurnIndicator();
                this.gameOver = false;
                this.winner = null;
                this.gameStarted = true; // Game restarts
                this.elements.gameOverScreen.style.display = 'none';
                this.elements.aiThinkingIndicator.style.display = 'none';

                if (this.gameMode === 'online' && this.socket) {
                    this.socket.emit('resetGame', this.roomId);
                } else if (this.gameMode === 'ai' && this.currentPlayer === 2) { // If AI starts as white
                    setTimeout(() => this.makeAIMove(), 1000);
                }
                this.showToast('Game ƒë√£ ƒë∆∞·ª£c l√†m l·∫°i!', 'info');
            }

            // AI Logic
            makeAIMove() {
                this.elements.aiThinkingIndicator.style.display = 'block';
                setTimeout(() => {
                    const validMoves = this.getValidMoves(this.currentPlayer);
                    if (validMoves.length > 0) {
                        let bestMove = null;
                        if (this.aiDifficulty === 'easy') {
                            bestMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                        } else if (this.aiDifficulty === 'medium') {
                            bestMove = this.getBestAIMove(this.board, this.currentPlayer, 2); // Look 2 moves ahead
                        } else if (this.aiDifficulty === 'hard') {
                            bestMove = this.getBestAIMove(this.board, this.currentPlayer, 4); // Look 4 moves ahead
                        }

                        if (bestMove) {
                            const flipped = this.getPiecesToFlip(bestMove.r, bestMove.c, this.currentPlayer);
                            this.applyMove(bestMove.r, bestMove.c, this.currentPlayer, flipped);
                            this.checkGameEnd();
                            if (!this.gameOver) {
                                this.switchTurn();
                            }
                        } else {
                            // No valid moves for AI, switch turn
                            this.showToast('AI kh√¥ng c√≥ n∆∞·ªõc ƒëi. Chuy·ªÉn l∆∞·ª£t!', 'info');
                            this.switchTurn();
                        }
                    } else {
                        // No valid moves for AI, switch turn
                        this.showToast('AI kh√¥ng c√≥ n∆∞·ªõc ƒëi. Chuy·ªÉn l∆∞·ª£t!', 'info');
                        this.switchTurn();
                    }
                    this.elements.aiThinkingIndicator.style.display = 'none';
                }, 1000); // Simulate AI thinking time
            }

            // Minimax algorithm for AI (simplified)
            getBestAIMove(board, player, depth) {
                let bestMove = null;
                let maxScore = -Infinity;
                const validMoves = this.getValidMovesForBoard(board, player);

                for (const move of validMoves) {
                    const newBoard = JSON.parse(JSON.stringify(board)); // Deep copy
                    const flipped = this.simulateMove(newBoard, move.r, move.c, player);
                    this.applySimulatedMove(newBoard, move.r, move.c, player, flipped);
                    const score = this.minimax(newBoard, player, depth - 1, false);

                    if (score > maxScore) {
                        maxScore = score;
                        bestMove = move;
                    }
                }
                return bestMove;
            }

            minimax(board, currentPlayer, depth, maximizingPlayer) {
                if (depth === 0 || this.isTerminal(board)) {
                    return this.evaluateBoard(board, this.currentPlayer); // Evaluate for the AI player (original caller)
                }

                const opponentPlayer = currentPlayer === 1 ? 2 : 1;
                const validMoves = this.getValidMovesForBoard(board, currentPlayer);

                if (maximizingPlayer) {
                    let maxEval = -Infinity;
                    if (validMoves.length === 0) { // No moves for maximizing player, pass turn
                        return this.minimax(board, opponentPlayer, depth - 1, false);
                    }
                    for (const move of validMoves) {
                        const newBoard = JSON.parse(JSON.stringify(board));
                        const flipped = this.simulateMove(newBoard, move.r, move.c, currentPlayer);
                        this.applySimulatedMove(newBoard, move.r, move.c, currentPlayer, flipped);
                        const evaluation = this.minimax(newBoard, opponentPlayer, depth - 1, false);
                        maxEval = Math.max(maxEval, evaluation);
                    }
                    return maxEval;
                } else {
                    let minEval = Infinity;
                    if (validMoves.length === 0) { // No moves for minimizing player, pass turn
                        return this.minimax(board, opponentPlayer, depth - 1, true);
                    }
                    for (const move of validMoves) {
                        const newBoard = JSON.parse(JSON.stringify(board));
                        const flipped = this.simulateMove(newBoard, move.r, move.c, currentPlayer);
                        this.applySimulatedMove(newBoard, move.r, move.c, currentPlayer, flipped);
                        const evaluation = this.minimax(newBoard, opponentPlayer, depth - 1, true);
                        minEval = Math.min(minEval, evaluation);
                    }
                    return minEval;
                }
            }

            isTerminal(board) {
                // Check if no more valid moves for either player or board is full
                return this.getValidMovesForBoard(board, 1).length === 0 && this.getValidMovesForBoard(board, 2).length === 0;
            }

            evaluateBoard(board, aiPlayerColor) {
                let aiScore = 0;
                let opponentScore = 0;
                const opponentColor = aiPlayerColor === 1 ? 2 : 1;

                // Simple piece count
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (board[r][c] === aiPlayerColor) aiScore++;
                        else if (board[r][c] === opponentColor) opponentScore++;
                    }
                }

                // Consider corners (very valuable)
                const corners = [
                    [0, 0], [0, 7], [7, 0], [7, 7]
                ];
                corners.forEach(([r, c]) => {
                    if (board[r][c] === aiPlayerColor) aiScore += 10;
                    else if (board[r][c] === opponentColor) opponentScore += 10;
                });

                // Consider edges (moderately valuable, but careful with X-squares next to corners)
                // This is a simplified heuristic. A real Othello AI would have a more complex evaluation.
                return aiScore - opponentScore;
            }

            getValidMovesForBoard(board, playerColor) {
                const validMoves = [];
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (board[r][c] === 0 && this.isValidMoveForBoard(board, r, c, playerColor)) {
                            validMoves.push({ r, c });
                        }
                    }
                }
                return validMoves;
            }

            isValidMoveForBoard(board, r, c, playerColor) {
                if (board[r][c] !== 0) return false;

                const opponentColor = playerColor === 1 ? 2 : 1;
                const directions = [
                    [-1, 0], [1, 0], [0, -1], [0, 1],
                    [-1, -1], [-1, 1], [1, -1], [1, 1]
                ];

                for (const [dr, dc] of directions) {
                    let foundOpponent = false;
                    let currentR = r + dr;
                    let currentC = c + dc;

                    while (currentR >= 0 && currentR < 8 && currentC >= 0 && currentC < 8) {
                        if (board[currentR][currentC] === opponentColor) {
                            foundOpponent = true;
                        } else if (board[currentR][currentC] === playerColor && foundOpponent) {
                            return true;
                        } else {
                            break;
                        }
                        currentR += dr;
                        currentC += dc;
                    }
                }
                return false;
            }

            simulateMove(board, r, c, playerColor) {
                const piecesToFlip = [];
                const opponentColor = playerColor === 1 ? 2 : 1;
                const directions = [
                    [-1, 0], [1, 0], [0, -1], [0, 1],
                    [-1, -1], [-1, 1], [1, -1], [1, 1]
                ];

                for (const [dr, dc] of directions) {
                    let line = [];
                    let currentR = r + dr;
                    let currentC = c + dc;
                    while (currentR >= 0 && currentR < 8 && currentC >= 0 && currentC < 8) {
                        if (board[currentR][currentC] === opponentColor) {
                            line.push({ r: currentR, c: currentC });
                        } else if (board[currentR][currentC] === playerColor) {
                            piecesToFlip.push(...line);
                            break;
                        } else {
                            break;
                        }
                        currentR += dr;
                        currentC += dc;
                    }
                }
                return piecesToFlip;
            }

            applySimulatedMove(board, r, c, playerColor, flippedPieces) {
                board[r][c] = playerColor;
                flippedPieces.forEach(({ r: flipR, c: flipC }) => {
                    board[flipR][flipC] = playerColor;
                });
            }

            // Socket.IO communication
            connectSocket() {
                if (this.socket) return; // Already connected or trying to connect
                this.socket = io();
                this.elements.connectionStatus.textContent = 'üîÑ ƒêang k·∫øt n·ªëi...';
                this.elements.connectionStatus.className = 'connection-status connecting';

                this.socket.on('connect', () => {
                    this.showToast('K·∫øt n·ªëi server th√†nh c√¥ng!', 'success');
                    this.elements.connectionStatus.textContent = '‚úÖ ƒê√£ k·∫øt n·ªëi';
                    this.elements.connectionStatus.className = 'connection-status connected';
                });

                this.socket.on('disconnect', () => {
                    this.showToast('M·∫•t k·∫øt n·ªëi server!', 'error');
                    this.elements.connectionStatus.textContent = '‚ùå M·∫•t k·∫øt n·ªëi';
                    this.elements.connectionStatus.className = 'connection-status disconnected';
                });

                this.socket.on('roomCreated', (roomId) => {
                    this.roomId = roomId;
                    this.isHost = true;
                    this.showScreen('room-lobby-screen');
                    this.elements.lobbyRoomId.textContent = roomId;
                    this.elements.displayRoomId.textContent = roomId;
                    const shareLink = `${window.location.origin}/?room=${roomId}`;
                    this.elements.shareLink.textContent = shareLink;
                    this.elements.startGameButton.disabled = true; // Wait for 2nd player
                    this.showToast(`Ph√≤ng ${roomId} ƒë√£ ƒë∆∞·ª£c t·∫°o! Ch·ªù ng∆∞·ªùi ch∆°i kh√°c.`, 'success');
                });

                this.socket.on('roomJoined', (room) => {
                    this.roomId = room.id;
                    this.isHost = false;
                    this.gameMode = room.gameMode;
                    this.isOnlineMode = true;
                    this.showScreen('room-lobby-screen');
                    this.elements.lobbyRoomId.textContent = room.id;
                    this.elements.displayRoomId.textContent = room.id;
                    const shareLink = `${window.location.origin}/?room=${room.id}`;
                    this.elements.shareLink.textContent = shareLink;
                    this.elements.startGameButton.style.display = 'none'; // Only host can start
                    this.updateLobbyPlayers(room.players);
                    this.showToast(`ƒê√£ tham gia ph√≤ng ${room.id}!`, 'success');
                });

                this.socket.on('roomJoinError', (message) => {
                    this.showToast(`L·ªói tham gia ph√≤ng: ${message}`, 'error');
                    this.showScreen('main-menu');
                });

                this.socket.on('playerJoined', (room) => {
                    this.updateLobbyPlayers(room.players);
                    if (this.isHost && room.players.length === 2) {
                        this.elements.startGameButton.disabled = false;
                        this.showToast('ƒê·ªß ng∆∞·ªùi ch∆°i! C√≥ th·ªÉ b·∫Øt ƒë·∫ßu game.', 'info');
                    }
                    this.showToast(`${room.players[room.players.length - 1].name} ƒë√£ tham gia ph√≤ng!`, 'info');
                });

                this.socket.on('playerLeft', (room) => {
                    this.updateLobbyPlayers(room.players);
                    if (this.isHost && room.players.length < 2) {
                        this.elements.startGameButton.disabled = true;
                        this.showToast('Ng∆∞·ªùi ch∆°i ƒë√£ r·ªùi ƒëi. ƒêang ch·ªù ng∆∞·ªùi ch∆°i kh√°c...', 'info');
                    }
                });

                this.socket.on('gameStarted', (room) => {
                    this.gameStarted = true;
                    this.isOnlineMode = true;
                    this.showScreen('game-screen');
                    this.board = room.board;
                    this.currentPlayer = room.currentPlayer;
                    this.updateScores();
                    this.updatePlayerNamesOnline(room.players);
                    this.updateTurnIndicator();
                    this.renderBoard();
                    this.showToast('Game ƒë√£ b·∫Øt ƒë·∫ßu!', 'success');
                });

                this.socket.on('gameStateUpdate', (room) => {
                    this.board = room.board;
                    this.currentPlayer = room.currentPlayer;
                    this.updateScores();
                    this.updateTurnIndicator();
                    this.renderBoard();
                });

                this.socket.on('invalidMove', (message) => {
                    this.showToast(`L·ªói n∆∞·ªõc ƒëi: ${message}`, 'error');
                });

                this.socket.on('gameEnded', (winnerName, finalScores) => {
                    this.gameOver = true;
                    this.winner = winnerName;
                    this.scores = finalScores;
                    this.endGame();
                    this.showToast('Game k·∫øt th√∫c!', 'info');
                });

                this.socket.on('playerDisconnectedInGame', (playerName, color) => {
                    this.showToast(`${playerName} (${this.playerEmojis[color]}) ƒë√£ ng·∫Øt k·∫øt n·ªëi!`, 'error');
                    // Mark player card as offline
                    if (color === 1) {
                        document.getElementById('player-black-card').classList.add('offline');
                    } else {
                        document.getElementById('player-white-card').classList.add('offline');
                    }
                });

                this.socket.on('playerReconnectedInGame', (playerName, color) => {
                    this.showToast(`${playerName} (${this.playerEmojis[color]}) ƒë√£ k·∫øt n·ªëi l·∫°i!`, 'success');
                    if (color === 1) {
                        document.getElementById('player-black-card').classList.remove('offline');
                    } else {
                        document.getElementById('player-white-card').classList.remove('offline');
                    }
                });

                this.socket.on('chatMessage', (data) => {
                    this.addChatMessage(data.sender, data.message, data.color);
                });

                this.socket.on('leaderboardData', (data) => {
                    this.renderLeaderboard(data);
                });

                this.socket.on('playerStatsData', (data) => {
                    this.renderStats(data);
                });

                this.socket.on('roomListUpdate', (rooms) => {
                    // Not directly used by this client, but useful for a lobby list
                    console.log('Room list updated:', rooms);
                });
            }

            updateLobbyPlayers(players) {
                this.elements.playersInLobby.textContent = `${players.length}/2`;
                this.elements.lobbyPlayerNames.innerHTML = players.map(p => {
                    const colorEmoji = p.color === 1 ? this.playerEmojis[1] : this.playerEmojis[2];
                    return `<span>${p.name} ${colorEmoji}</span>`;
                }).join(' & ');
            }

            updatePlayerNamesOnline(players) {
                const player1 = players.find(p => p.color === 1);
                const player2 = players.find(p => p.color === 2);

                if (player1) {
                    this.elements.playerBlackName.textContent = player1.name;
                    this.playerEmojis[1] = this.selectedPlayerEmoji[1]; // Ensure current player emoji is used
                    // If AI, add AI class
                    if (player1.name === 'AI') {
                        document.getElementById('player-black-card').classList.add('ai');
                    } else {
                        document.getElementById('player-black-card').classList.remove('ai');
                    }
                }
                if (player2) {
                    this.elements.playerWhiteName.textContent = player2.name;
                    this.playerEmojis[2] = this.selectedPlayerEmoji[2]; // Ensure current player emoji is used
                    // If AI, add AI class
                    if (player2.name === 'AI') {
                        document.getElementById('player-white-card').classList.add('ai');
                    } else {
                        document.getElementById('player-white-card').classList.remove('ai');
                    }
                }
            }


            addChatMessage(sender, message, color = null) {
                const messageElement = document.createElement('div');
                messageElement.classList.add('chat-message');
                let senderText = sender;
                if (color) {
                    senderText += ` ${this.playerEmojis[color]}`;
                }
                messageElement.innerHTML = `<span class="chat-sender">${senderText}:</span> ${message}`;
                this.elements.chatMessages.appendChild(messageElement);
                this.elements.chatMessages.scrollTop = this.elements.chatMessages.scrollHeight; // Auto-scroll
            }

            sendChatMessage() {
                const message = this.elements.chatInput.value.trim();
                if (message) {
                    if (this.isOnlineMode && this.socket) {
                        this.socket.emit('chatMessage', this.roomId, message);
                    } else {
                        // For offline/AI modes, just display locally
                        this.addChatMessage(this.playerName, message);
                    }
                    this.elements.chatInput.value = '';
                }
            }

            loadLeaderboardData() {
                if (this.isOnlineMode && this.socket) {
                    this.elements.leaderboardList.innerHTML = '<p>ƒêang t·∫£i b·∫£ng x·∫øp h·∫°ng...</p>';
                    this.socket.emit('getLeaderboard');
                } else {
                    this.elements.leaderboardList.innerHTML = '<p>T√≠nh nƒÉng n√†y ch·ªâ c√≥ ·ªü ch·∫ø ƒë·ªô Online.</p>';
                }
            }

            renderLeaderboard(data) {
                const list = this.elements.leaderboardList;
                list.innerHTML = '';
                if (data.length === 0) {
                    list.innerHTML = '<p>Ch∆∞a c√≥ d·ªØ li·ªáu b·∫£ng x·∫øp h·∫°ng.</p>';
                    return;
                }
                data.forEach((entry, index) => {
                    const item = document.createElement('li');
                    item.classList.add('leaderboard-item');
                    item.innerHTML = `
                        <span class="leaderboard-rank">${index + 1}.</span>
                        <span class="leaderboard-name">${entry.name}</span>
                        <span class="leaderboard-rating">${entry.rating} Rating (${entry.wins}W-${entry.losses}L)</span>
                    `;
                    list.appendChild(item);
                });
            }

            loadStatsData(playerName) {
                if (this.isOnlineMode && this.socket) {
                    this.elements.statsPlayerName.textContent = playerName;
                    this.elements.statsList.innerHTML = '<p>ƒêang t·∫£i th·ªëng k√™...</p>';
                    this.socket.emit('getPlayerStats', playerName);
                } else {
                    this.elements.statsPlayerName.textContent = this.playerName || 'B·∫°n';
                    this.elements.statsList.innerHTML = '<p>T√≠nh nƒÉng n√†y ch·ªâ c√≥ ·ªü ch·∫ø ƒë·ªô Online.</p>';
                }
            }

            renderStats(data) {
                const statsDiv = this.elements.statsList;
                statsDiv.innerHTML = '';
                if (!data) {
                    statsDiv.innerHTML = '<p>Kh√¥ng t√¨m th·∫•y th·ªëng k√™ cho ng∆∞·ªùi ch∆°i n√†y.</p>';
                    return;
                }
                statsDiv.innerHTML = `
                    <div class="stat-item"><span>T·ªïng s·ªë tr·∫≠n:</span><span>${data.totalGames}</span></div>
                    <div class="stat-item"><span>Th·∫Øng:</span><span>${data.wins}</span></div>
                    <div class="stat-item"><span>Thua:</span><span>${data.losses}</span></div>
                    <div class="stat-item"><span>H√≤a:</span><span>${data.ties}</span></div>
                    <div class="stat-item"><span>ƒêi·ªÉm ghi ƒë∆∞·ª£c:</span><span>${data.pointsScored || 0}</span></div>
                    <div class="stat-item"><span>ƒêi·ªÉm b·ªã m·∫•t:</span><span>${data.pointsConceded || 0}</span></div>
                `;
            }

            showRules() {
                this.elements.rulesModal.style.display = 'flex';
            }

            closeModal() {
                this.elements.rulesModal.style.display = 'none';
            }

            switchTab(tabName) {
                document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

                document.querySelector(`.tab[data-tab="${tabName}"]`).classList.add('active');
                document.getElementById(`${tabName}-content`).classList.add('active');

                if (tabName === 'leaderboard-tab') {
                    this.loadLeaderboardData();
                } else if (tabName === 'stats-tab') {
                    this.loadStatsData(this.playerName);
                }
            }


            // UI Navigation functions (called from HTML)
            createRoom(mode) {
                this.savePlayerName();
                if (!this.playerName) {
                    this.showToast('Vui l√≤ng nh·∫≠p t√™n c·ªßa b·∫°n!', 'error');
                    return;
                }
                this.gameMode = mode;
                if (mode === 'online') {
                    this.connectSocket();
                    this.socket.emit('createRoom', this.playerName);
                    this.isOnlineMode = true;
                    this.elements.gameContainer.classList.remove('local-ai-layout'); // Ensure online layout
                }
            }

            showJoinRoom() {
                this.savePlayerName();
                if (!this.playerName) {
                    this.showToast('Vui l√≤ng nh·∫≠p t√™n c·ªßa b·∫°n!', 'error');
                    return;
                }
                this.showScreen('join-room-screen');
                this.connectSocket(); // Ensure socket is connected before joining
            }

            joinRoom() {
                const roomIdToJoin = this.elements.roomIdInput.value.trim().toUpperCase();
                if (!roomIdToJoin) {
                    this.showToast('Vui l√≤ng nh·∫≠p ID ph√≤ng!', 'error');
                    return;
                }
                this.savePlayerName();
                if (!this.playerName) {
                    this.showToast('Vui l√≤ng nh·∫≠p t√™n c·ªßa b·∫°n!', 'error');
                    return;
                }
                this.connectSocket();
                this.socket.emit('joinRoom', roomIdToJoin, this.playerName);
                this.isOnlineMode = true;
                this.elements.gameContainer.classList.remove('local-ai-layout'); // Ensure online layout
            }

            copyShareLink() {
                const shareLinkText = this.elements.shareLink.textContent;
                navigator.clipboard.writeText(shareLinkText).then(() => {
                    this.showToast('ƒê√£ sao ch√©p link chia s·∫ª!', 'success');
                }).catch(err => {
                    console.error('Kh√¥ng th·ªÉ sao ch√©p link: ', err);
                    this.showToast('Kh√¥ng th·ªÉ sao ch√©p link.', 'error');
                });
            }

            startGame() {
                if (this.isHost && this.socket) {
                    this.socket.emit('startGame', this.roomId);
                }
            }

            leaveRoom() {
                if (this.socket) {
                    this.socket.emit('leaveRoom', this.roomId);
                    this.socket.disconnect();
                    this.socket = null;
                }
                this.roomId = null;
                this.isHost = false;
                this.gameMode = 'offline';
                this.isOnlineMode = false;
                this.elements.gameContainer.classList.remove('local-ai-layout'); // Reset layout
                this.showScreen('main-menu');
                this.showToast('ƒê√£ r·ªùi ph√≤ng.', 'info');
            }

            leaveGame() {
                if (this.isOnlineMode && this.socket) {
                    this.socket.emit('leaveGame', this.roomId); // Notify server of game leave
                    this.socket.disconnect();
                    this.socket = null;
                }
                this.roomId = null;
                this.isHost = false;
                this.gameMode = 'offline';
                this.isOnlineMode = false;
                this.elements.gameContainer.classList.remove('local-ai-layout'); // Reset layout
                this.showScreen('main-menu');
                this.elements.gameOverScreen.style.display = 'none'; // Hide game over screen
                this.showToast('ƒê√£ tho√°t game.', 'info');
            }

            showAIMenu() {
                this.savePlayerName();
                if (!this.playerName) {
                    this.showToast('Vui l√≤ng nh·∫≠p t√™n c·ªßa b·∫°n!', 'error');
                    return;
                }
                this.showScreen('ai-menu-screen');
            }

            createAIRoom() {
                this.savePlayerName();
                if (!this.playerName) {
                    this.showToast('Vui l√≤ng nh·∫≠p t√™n c·ªßa b·∫°n!', 'error');
                    return;
                }
                this.gameMode = 'ai';
                this.isOnlineMode = false;
                this.aiDifficulty = document.getElementById('ai-difficulty').value;

                this.initializeBoard();
                this.elements.playerBlackName.textContent = this.playerName;
                this.elements.playerWhiteName.textContent = 'AI ' + this.aiDifficulty.toUpperCase();
                document.getElementById('player-black-card').classList.remove('offline');
                document.getElementById('player-white-card').classList.remove('offline');
                document.getElementById('player-white-card').classList.add('ai'); // Mark AI player

                this.elements.gameContainer.classList.add('local-ai-layout'); // Apply AI/Local layout
                this.showScreen('game-screen');
                this.gameStarted = true;
                this.renderBoard();
                this.updateScores();
                this.updateTurnIndicator();
                this.showToast('B·∫Øt ƒë·∫ßu ch∆°i v·ªõi AI!', 'success');

                if (this.currentPlayer === 2) { // If AI starts as white
                    setTimeout(() => this.makeAIMove(), 1000);
                }
            }

            playOffline() {
                this.savePlayerName();
                if (!this.playerName) {
                    this.showToast('Vui l√≤ng nh·∫≠p t√™n c·ªßa b·∫°n!', 'error');
                    return;
                }
                this.gameMode = 'offline';
                this.isOnlineMode = false;

                this.initializeBoard();
                this.elements.playerBlackName.textContent = this.playerName;
                this.elements.playerWhiteName.textContent = 'Ng∆∞·ªùi ch∆°i 2';
                document.getElementById('player-black-card').classList.remove('offline');
                document.getElementById('player-white-card').classList.remove('offline');
                document.getElementById('player-white-card').classList.remove('ai'); // Remove AI class if present

                this.elements.gameContainer.classList.add('local-ai-layout'); // Apply AI/Local layout
                this.showScreen('game-screen');
                this.gameStarted = true;
                this.renderBoard();
                this.updateScores();
                this.updateTurnIndicator();
                this.showToast('B·∫Øt ƒë·∫ßu ch∆°i c·ª•c b·ªô!', 'success');
            }

            backToMenu() {
                this.showScreen('main-menu');
            }

            showLeaderboard() {
                this.showScreen('game-screen'); // Re-use game screen for now for simplicity of tabs
                this.switchTab('leaderboard-tab');
            }

            showStats() {
                this.showScreen('game-screen'); // Re-use game screen for now for simplicity of tabs
                this.switchTab('stats-tab');
            }
        }

        // Global functions to be called from HTML
        function createRoom(mode) { game.createRoom(mode); }
        function showJoinRoom() { game.showJoinRoom(); }
        function joinRoom() { game.joinRoom(); }
        function copyShareLink() { game.copyShareLink(); }
        function startGame() { game.startGame(); }
        function leaveRoom() { game.leaveRoom(); }
        function leaveGame() { game.leaveGame(); }
        function resetGame() { game.resetGame(); }
        function showRules() { game.showRules(); }
        function closeModal() { game.closeModal(); }
        function sendChatMessage() { game.sendChatMessage(); }
        function switchTab(tabName) { game.switchTab(tabName); }
        function showAIMenu() { game.showAIMenu(); }
        function createAIRoom() { game.createAIRoom(); }
        function playOffline() { game.playOffline(); }
        function backToMenu() { game.backToMenu(); }
        function showLeaderboard() { game.showLeaderboard(); }
        function showStats() { game.showStats(); }

        // Initialize game when page loads
        window.addEventListener('DOMContentLoaded', () => {
            game = new EnhancedOthelloGame();

            // Check for room ID in URL
            const urlParams = new URLSearchParams(window.location.search);
            const roomId = urlParams.get('room');
            if (roomId) {
                document.getElementById('room-id-input').value = roomId;
                game.showJoinRoom();
                // Automatically attempt to join the room if a name is provided
                const playerName = localStorage.getItem('playerName');
                if (playerName) {
                    game.elements.playerNameInput.value = playerName; // Set player name input
                    setTimeout(() => { // Give UI a moment to update
                        game.joinRoom(); // Attempt to join with the URL ID
                    }, 100);
                } else {
                    game.showToast('Vui l√≤ng nh·∫≠p t√™n c·ªßa b·∫°n ƒë·ªÉ tham gia ph√≤ng.', 'info');
                }
            }
        });

        // Handle page visibility change (reconnect socket if disconnected when page becomes visible)
        document.addEventListener('visibilitychange', () => {
            if (game && game.isOnlineMode && game.socket) {
                if (document.hidden) {
                    // Page hidden - no action needed for now
                } else {
                    // Page visible - reconnect if needed
                    if (game.socket.disconnected) {
                        game.showToast('ƒêang k·∫øt n·ªëi l·∫°i...', 'info');
                        game.socket.connect();
                    }
                }
            }
        });
    </script>
</body>
</html>
